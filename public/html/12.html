<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
        <text y='0.9em' font-size='90'>ğŸ‘½</text>
      </svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <title>Murtaza AL-Omran | Portfolio</title>
    <style>
        :root {
            --fg: #e6f3ff;
            --sub: #9fbcd6;
            --glow: #49c2ff;
            --accent: #36a3ff;
            --bg1: #02040a;
            --bg2: #000000;

            --ac: #299deb;
        }

        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        html {
            padding: 0;
            margin: 0;
            width: 100dvw;
            height: 100dvh;
            background-color: #000;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at 50% 60%, #001022 0%, #000614 70%, #000000 100%);
        }

        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                radial-gradient(900px 700px at 50% 90%, rgba(0, 100, 255, 0.25) 0%, transparent 70%),
                radial-gradient(1200px 800px at 50% 40%, rgba(0, 60, 255, 0.15) 0%, transparent 80%);
            animation: shimmer 6s ease-in-out infinite alternate;
            z-index: 0;
        }

        canvas {
            position: fixed;
            inset: 0;
            z-index: 1;
            background: transparent !important;
        }

        @keyframes shimmer {
            0% {
                opacity: 0.25;
                filter: blur(20px);
            }

            50% {
                opacity: 0.55;
                filter: blur(40px);
            }

            100% {
                opacity: 0.25;
                filter: blur(20px);
            }
        }

        canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100dvh;
            display: block;
            z-index: 0;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 2;
            pointer-events: none;
            background-color: transparent;
        }

        .hero {
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            z-index: 2;
        }

        .hero h1 {
            font-weight: 100;
            font-size: 4rem;
            letter-spacing: 0.2em;
            color: var(--fg);
            text-shadow: 0 0 20px rgba(73, 194, 255, 0.2);
        }

        .hero p {
            font-size: 1rem;
            margin-top: 0.8rem;
            color: var(--sub);
            opacity: 0.9;
            letter-spacing: 0.25em;
        }

        nav {
            position: absolute;
            bottom: 32px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 18px;
            z-index: 2;
        }

        nav a {
            pointer-events: auto;
            text-decoration: none;
            font-size: 0.9rem;
            color: #a9c5dc;
            padding: 6px 10px;
            border-radius: 8px;
            transition: color 0.25s, background 0.25s;
        }

        nav a:hover {
            color: var(--fg);
            background: rgba(73, 194, 255, 0.1);
        }

        .vignette {
            position: fixed;
            inset: 0;
            z-index: 1;
            pointer-events: none;
            background: radial-gradient(1000px 600px at 50% 40%, transparent 60%, rgba(0, 0, 0, 0.3) 100%),
                linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.25) 100%);
        }

        /* Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ */
        @media (max-width: 768px) {
            .hero {
                top: 30%;
            }

            .hero h1 {
                font-size: 2.2rem;
                letter-spacing: 0.12em;
            }

            .hero p {
                font-size: 0.8rem;
                letter-spacing: 0.18em;
            }

            nav {
                bottom: 20px;
                gap: 12px;
            }

            nav a {
                font-size: 0.75rem;
                padding: 5px 8px;
            }
        }

        @media (max-width: 420px) {
            .hero h1 {
                font-size: 1.8rem;
            }

            .hero p {
                font-size: 0.7rem;
            }

            nav {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 10px;
                bottom: 18px;
            }
        }
    </style>
</head>

<body>
    <div class="overlay">
        <div class="hero">
            <h1>MURTAZA&nbsp;AL-OMRAN</h1>
            <p>CREATIVE&nbsp;|&nbsp;TECHNOLOGIST&nbsp;|&nbsp;DEVELOPER</p>
        </div>
    </div>
    <nav>
        <a href="#">WORK</a>
        <a href="#">PROTOTYPES</a>
        <a href="#">ART</a>
        <a href="#">PRESS</a>
        <a href="#">INFO</a>
        <a href="#">REEL</a>
    </nav>
    <!-- <div class="vignette"></div> -->

    <!-- Three.js + Postprocessing (ESM) -->
    <script type="module">
        import * as THREE from "https://esm.sh/three@0.159.0";
        import { EffectComposer } from "https://esm.sh/three@0.159.0/examples/jsm/postprocessing/EffectComposer.js";
        import { RenderPass } from "https://esm.sh/three@0.159.0/examples/jsm/postprocessing/RenderPass.js";
        import { UnrealBloomPass } from "https://esm.sh/three@0.159.0/examples/jsm/postprocessing/UnrealBloomPass.js";

        let scene, camera, renderer, composer, clock;
        let coreMesh, ringGroup, dotCloud, bgMesh;
        let alpha = 0, beta = 0, gamma = 0;


        init();
        requestMotionPermission();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
            camera.position.set(0, 0, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.setClearColor(0x000000, 0); // â† ÙŠÙ…Ù†Ø¹ Ø£ÙŠ Ø´ÙØ§ÙÙŠØ© Ø£Ùˆ Ø¨ÙŠØ§Ø¶ Ø¨Ø§Ù„Ø®Ù„Ù
            renderer.autoClear = false; // â† Ø£Ù‡Ù… Ø³Ø·Ø± ÙŠÙ…Ù†Ø¹ Ø§Ù„Ù…Ø³Ø­ ÙƒÙ„ ÙØ±ÙŠÙ…
            document.body.appendChild(renderer.domElement);


            clock = new THREE.Clock();

            // Ø¥Ø¶Ø§Ø¡Ø© Ù†ÙŠÙ„ÙŠÙ‘Ø© Ø¨Ø§Ø±Ø¯Ø©
            const hemi = new THREE.HemisphereLight(0x6699ff, 0x000011, 0.8);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0x66ccff, 1.2);
            dir.position.set(4, 5, 6);
            scene.add(dir);

            // Ø§Ù„Ù†ÙˆØ§Ø© Ø§Ù„Ù†ÙŠÙ„ÙŠÙ‘Ø©
            coreMesh = makeFresnelCore();
            scene.add(coreMesh);

            // Ø§Ù„Ø­Ù„Ù‚Ø§Øª
            ringGroup = new THREE.Group();
            scene.add(ringGroup);
            makeRings();

            // Ø§Ù„Ù†Ù‚Ø§Ø·
            dotCloud = makeOrbitDots();
            scene.add(dotCloud);

            // bloom Ø¨Ø³ÙŠØ·
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 0.8, 0.2);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            window.addEventListener("resize", onResize);
        }

        function onResize() {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
            composer.setSize(innerWidth, innerHeight);
        }

        // Ø§Ù„Ù†ÙˆØ§Ø©
        function makeFresnelCore() {
            const geo = new THREE.IcosahedronGeometry(1.15, 3);
            const mat = new THREE.ShaderMaterial({
                uniforms: { uColor: { value: new THREE.Color("#0866b3") } },
                vertexShader: `
      varying vec3 vWorldPos;
      varying vec3 vNormal;
      void main(){
        vNormal = normalize(normalMatrix * normal);
        vec4 wp = modelMatrix * vec4(position, 1.0);
        vWorldPos = wp.xyz;
        gl_Position = projectionMatrix * viewMatrix * wp;
      }`,
                fragmentShader: `
      varying vec3 vWorldPos;
      varying vec3 vNormal;
      uniform vec3 uColor;
      void main(){
        vec3 V = normalize(cameraPosition - vWorldPos);
        float fresnel = pow(1.0 - max(dot(V, vNormal), 0.0), 2.2);
        vec3 col = mix(vec3(0.02,0.05,0.1), uColor, fresnel * 1.8);
        gl_FragColor = vec4(col, 1.0);
      }`,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            return new THREE.Mesh(geo, mat);
        }


        // Ø§Ù„Ø­Ù„Ù‚Ø§Øª
        function makeRings() {
            for (let i = 0; i < 6; i++) {
                const r = 1.8 + i * 0.45;
                const tube = 0.006 + i * 0.003;
                const ringGeo = new THREE.TorusGeometry(r, tube, 6, 300);
                const hue = 0.58 + i * 0.015; // ØªØ¯Ø±Ù‘Ø¬ Ù…Ù† Ù†ÙŠÙ„ÙŠ Ù„Ø£Ø²Ø±Ù‚
                const ringMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(hue, 1, 0.55),
                    transparent: true,
                    opacity: 0.6 - i * 0.06,
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.rotation.y = i * 0.18;
                ringGroup.add(ring);
            }
        }


        // Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¯Ø§Ø±ÙŠØ©
        function makeOrbitDots() {
            const dotGeo = new THREE.SphereGeometry(0.016, 8, 8);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x299deb });
            const maxDots = 2400; // â† ÙƒØ§Ù† 800ØŒ ØµØ±Ù‘ Ø£ÙƒØ«Ø±
            const inst = new THREE.InstancedMesh(dotGeo, dotMat, maxDots);
            inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            const data = [];
            for (let r = 0; r < 20; r++) { // â† ÙƒØ§Ù† 6ØŒ Ø²Ø¯Ù†Ø§ Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ù…Ø¯Ø§Ø±ÙŠØ©
                const radius = 1.3 + r * 0.4; // â† ØªÙ‚Ø±Ù‘Ø¨Øª Ø´ÙˆÙŠ Ù„Ù„Ù†ÙˆØ§Ø©
                const count = 200 + r * 80; // â† Ø¶Ø¹Ù Ø§Ù„Ø¹Ø¯Ø¯ Ø¯Ø§Ø®Ù„ ÙƒÙ„ Ù…Ø¯Ø§Ø±
                for (let k = 0; k < count; k++) {
                    const ang = Math.random() * Math.PI * 2;
                    const tiltX = r * 0.08 + Math.random() * 0.06;
                    const tiltY = r * 0.05 + Math.random() * 0.06;
                    data.push({ radius, ang, tiltX, tiltY });
                    if (data.length >= maxDots) break;
                }
                if (data.length >= maxDots) break;
            }

            inst.userData.orbits = data;
            return inst;
        }

        // Ø¯ÙˆØ±Ø§Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø­ÙˆÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªØ´Ø¹Ø±
        function handleOrientation(event) {
            alpha = THREE.MathUtils.degToRad(event.alpha || 0); // Ø¯ÙˆØ±Ø§Ù† Ø­ÙˆÙ„ Ø§Ù„Ù…Ø­ÙˆØ± Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ (Z)
            beta = THREE.MathUtils.degToRad(event.beta - 35 || 0);   // Ù…ÙŠÙ„ Ù„Ù„Ø£Ù…Ø§Ù… ÙˆØ§Ù„Ø®Ù„Ù (X)
            gamma = THREE.MathUtils.degToRad(event.gamma || 0); // Ù…ÙŠÙ„ Ø¬Ø§Ù†Ø¨ÙŠ (Y)
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø©
            ringGroup.rotation.y += 0.0015;
            coreMesh.rotation.y -= 0.001;

            // ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø­ÙˆÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
            const radius = 8;
            const x = radius * Math.sin(gamma) * Math.cos(beta);
            const y = radius * Math.sin(beta);
            const z = radius * Math.cos(gamma) * Math.cos(beta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);

            // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¯Ø§Ø±ÙŠØ©
            const inst = dotCloud;
            const data = inst.userData.orbits;
            const m = new THREE.Matrix4();
            for (let i = 0; i < data.length; i++) {
                const o = data[i];
                const ang = o.ang + t * 0.15;
                const px = Math.cos(ang) * o.radius;
                const pz = Math.sin(ang) * o.radius;
                const py = Math.sin(ang * 2.0 + o.radius) * 0.08;
                const pos = new THREE.Vector3(px, py, pz).applyEuler(new THREE.Euler(o.tiltX, o.tiltY, 0));
                m.makeTranslation(pos.x, pos.y, pos.z);
                inst.setMatrixAt(i, m);
            }
            inst.instanceMatrix.needsUpdate = true;

            renderer.clearDepth();
            composer.render();
        }

        // Ø·Ù„Ø¨ Ø§Ù„Ø¥Ø°Ù† Ù„Ù„Ù…Ø³ØªØ´Ø¹Ø±
        function requestMotionPermission() {
            if (typeof DeviceOrientationEvent.requestPermission === "function") {
                document.body.addEventListener("click", async () => {
                    const res = await DeviceOrientationEvent.requestPermission();
                    if (res === "granted") {
                        window.addEventListener("deviceorientation", handleOrientation, true);
                    } else alert("âŒ Ø±ÙØ¶Øª Ø§Ù„Ø¥Ø°Ù†");
                }, { once: true });
            } else {
                window.addEventListener("deviceorientation", handleOrientation, true);
            }
        }
    </script>
</body>

</html>